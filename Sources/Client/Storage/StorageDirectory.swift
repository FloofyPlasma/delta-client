import Foundation
import SwiftUI
import DeltaCore

/// An error thrown by ``StorageDirectory``.
enum StorageDirectoryError: LocalizedError {
  case failedToCreateBackup

  var errorDescription: String? {
    switch self {
      case .failedToCreateBackup:
        return "Failed to create backup of storage directory."
    }
  }
}

struct StorageDirectoryEnvironmentKey: EnvironmentKey {
  static let defaultValue: StorageDirectory = StorageDirectory(URL(fileURLWithPath: "."))
}

extension EnvironmentValues {
  var storage: StorageDirectory {
    get { self[StorageDirectoryEnvironmentKey.self] }
    set { self[StorageDirectoryEnvironmentKey.self] = newValue }
  }
}

// TODO: Find if there's a way to just have this as a struct (it's just immutable data, but needs
//   to be a class).
/// A wrapper around Delta Client's storage directory URL. Used to define a consistent structure,
/// and house useful helper methods. Never guarantees that the described directories exist.
struct StorageDirectory {
  /// The default storage directory for the current platform.
  static var platformDefault: StorageDirectory? {
    #if os(macOS) || os(iOS)
      let options = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
      let base = options.first?.appendingPathComponent("dev.stackotter.delta-client")
      return base.map(StorageDirectory.init)
    #elseif os(Linux)
      #error("Linux storage directory not implemented")
    #endif
  }

  /// The root of the storage directory.
  private(set) var baseDirectory: URL

  /// A custom plugin directory which overrides the default plugin directory
  /// location. Set to `nil` for ``StorageDirectory/pluginDirectory`` to go
  /// back to the default.
  var pluginDirectoryOverride: URL?

  /// The directory for assets (e.g. the vanilla resource pack).
  var assetDirectory: URL {
    baseDirectory.appendingPathComponent("assets")
  }

  /// The directory for registries (e.g. the block registry and item registry).
  var registryDirectory: URL {
    baseDirectory.appendingPathComponent("registries")
  }

  /// The directory for user-installed plugins.
  var pluginDirectory: URL {
    pluginDirectoryOverride ?? baseDirectory.appendingPathComponent("plugins")
  }

  /// The directory for performance-enhancing caches.
  var cacheDirectory: URL {
    baseDirectory.appendingPathComponent("cache")
  }

  /// The directory for GPU captures (traces).
  var gpuCaptureDirectory: URL {
    baseDirectory.appendingPathComponent("captures")
  }

  /// The directory to store log files.
  var logDirectory: URL {
    baseDirectory.appendingPathComponent("logs")
  }

  /// The current log file.
  var currentLogFile: URL {
    logDirectory.appendingPathComponent("delta-client.log")
  }

  /// Initializes a storage directory (without guaranteeing that it exists).
  init(_ base: URL) {
    baseDirectory = base
  }

  /// Creates a unique GPU capture output file path of the form
  /// `capture_dd-MM-yyyy_HH-mm-ss.gputrace`.
  func uniqueGPUCaptureFile() -> URL {
    let date = Date()
    let formatter = DateFormatter()
    formatter.dateFormat = "dd-MM-yyyy_HH-mm-ss"

    let fileName = "capture_\(formatter.string(from: date)).gputrace"
    return gpuCaptureDirectory.appendingPathComponent(fileName)
  }

  /// Creates the storage directory if it doesn't already exist.
  func ensureCreated() throws {
    guard !FileSystem.itemExists(baseDirectory) else {
      return
    }

    try FileSystem.createDirectory(baseDirectory)
  }

  /// Gets the location of the resource pack cache for the pack with the given name.
  func cache(forResourcePackNamed name: String) -> URL {
    cacheDirectory.appendingPathComponent("\(name).rpcache")
  }

  /// Gets the URL to a file with the given name in the storage directory.
  func file(_ name: String) -> URL {
    baseDirectory.appendingPathComponent(name)
  }

  /// Creates a backup of the storage directory. If an output file isn't supplied, a
  /// filename is autogenerated from the current datetime, and the backup is stored
  /// in the base of the storage directory.
  ///
  /// If `zipFile` is provided, and the file already exists, its existing contents
  /// get overwritten.
  func backup(to zipFile: URL? = nil) throws {
    let backupFile: URL
    if let zipFile = zipFile {
      backupFile = zipFile
    } else {
      let date = Date()
      let formatter = DateFormatter()
      formatter.dateFormat = "dd-MM-yyyy_HH-mm-ss"

      let backupName = "backup_\(formatter.string(from: date))"
      backupFile = file("\(backupName).zip")
    }

    do {
      try FileManager.default.zipItem(at: baseDirectory, to: backupFile)
    } catch {
      throw StorageDirectoryError.failedToCreateBackup.becauseOf(error)
    }
  }

  /// Resets the contents of the storage directory. If `keepBackups` is true, then
  /// any files which begin with `backup` won't get deleted.
  func reset(keepBackups: Bool = true) throws {
    let contents = try FileSystem.children(of: baseDirectory)
    for item in contents {
      // Remove item if it is not a backup
      if !(keepBackups && item.lastPathComponent.hasPrefix("backup")) {
        try FileSystem.remove(item)
      }
    }
  }

  /// Removes all caches from the storage directory.
  func removeCache() throws {
    try FileSystem.remove(cacheDirectory)
  }
}
